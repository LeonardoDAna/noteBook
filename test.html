<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    const PENDING = 'pending'
    const FULFILLED = 'fulfilled'
    const REJECTED = 'rejected'

    function Promise(executor) {
      let _this = this
      _this.status = 'pending'
      _this.data = undefined
      _this.onResolvedCallback = []
      _this.onRejectedCallback = []

      function resolve(value) {
        if (_this.status == 'pending') {
          _this.status = FULFILLED
          _this.data = value
          for (let i = 0; i < _this.onResolvedCallback.length; i++) {
            _this.onResolvedCallback[i](value)
          }
        }
      }

      function reject(resaon) {
        if (_this.status == 'pending') {
          _this.status = REJECTED
          _this.data = resaon
          for (let i = 0; i < _this.onRejectedCallback.length; i++) {
            _this.onRejectedCallback[i](resaon)
          }
        }
      }
      try {
        executor(resolve, reject)
      } catch (e) {
        reject(e)
      }
    }

    Promise.prototype.then = function (onFulfillde, onRejected) {
      let _this = this
      let promise2

      onFulfillde = typeof onFulfillde === 'function' ? onFulfillde : value => value
      onRejected = typeof onRejected === 'function' ? onRejected : resaon => {
        throw resaon
      }

      if (_this.status === FULFILLED) {
        return promise2 = new Promise(function (resolve, reject) {
          try {
            let x = onFulfillde(_this.data)
            if (x instanceof Promise) {
              x.then(resolve, reject)
            }
            resolve(x)
          } catch (e) {
            reject(e)
          }
        })
      }
      if (_this.status === REJECTED) {
        return promise2 = new Promise(function (resolve, reject) {
          try {
            let x = onRejected(_this.data)
            if (x instanceof Promise) {
              x.then(resolve, reject)
            }
          } catch (e) {
            reject(e)
          }
        })
      }
      if (_this.status === PENDING) {
        return promise2 = new Promise(function (resolve, reject) {
          _this.onResolvedCallback.push(function (value) {
            try {
              let x = onFulfillde(_this.data)
              if (x instanceof promise) {
                x.then(resolve, reject)
              }
            } catch (e) {
              reject(e)
            }
          })
          _this.onRejectedCallback.push(function (resolve, reject) {
            try {
              let x = onRejected(_this.data)
              if (x instanceof promise) {
                x.then(resolve, reject)
              }
            } catch (e) {
              reject(e)
            }
          })
        })
      }
    }
  </script>
</body>

</html>